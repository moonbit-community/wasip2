// Generated by `wit-bindgen` 0.49.0. DO NOT EDIT!

///|
pub(all) enum ShutdownType {
  RECEIVE
  SEND
  BOTH
} derive(Show, Eq)

///|
pub fn ShutdownType::ordinal(self : ShutdownType) -> Int {
  match self {
    RECEIVE => 0
    SEND => 1
    BOTH => 2
  }
}

///|
pub fn ShutdownType::from(self : Int) -> ShutdownType {
  match self {
    0 => RECEIVE
    1 => SEND
    2 => BOTH
    _ => panic()
  }
}

///|
pub(all) struct TcpSocket(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn TcpSocket::drop(self : TcpSocket) -> Unit {
  let TcpSocket(resource) = self
  wasmImportResourceDropTcpSocket(resource)
}

///|
pub fn TcpSocket::start_bind(
  self : TcpSocket,
  network : @network.Network,
  local_address : @network.IpSocketAddress,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered2,
    lowered3,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
  ) = match local_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload1) =>
      (
        1,
        payload1.port.reinterpret_as_int(),
        payload1.flow_info.reinterpret_as_int(),
        payload1.address.0.reinterpret_as_int(),
        payload1.address.1.reinterpret_as_int(),
        payload1.address.2.reinterpret_as_int(),
        payload1.address.3.reinterpret_as_int(),
        payload1.address.4.reinterpret_as_int(),
        payload1.address.5.reinterpret_as_int(),
        payload1.address.6.reinterpret_as_int(),
        payload1.address.7.reinterpret_as_int(),
        payload1.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketStartBind(
    handle, handle0, lowered, lowered2, lowered3, lowered4, lowered5, lowered6, lowered7,
    lowered8, lowered9, lowered10, lowered11, lowered12, return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_bind(
  self : TcpSocket,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketFinishBind(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::start_connect(
  self : TcpSocket,
  network : @network.Network,
  remote_address : @network.IpSocketAddress,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered2,
    lowered3,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
  ) = match remote_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload1) =>
      (
        1,
        payload1.port.reinterpret_as_int(),
        payload1.flow_info.reinterpret_as_int(),
        payload1.address.0.reinterpret_as_int(),
        payload1.address.1.reinterpret_as_int(),
        payload1.address.2.reinterpret_as_int(),
        payload1.address.3.reinterpret_as_int(),
        payload1.address.4.reinterpret_as_int(),
        payload1.address.5.reinterpret_as_int(),
        payload1.address.6.reinterpret_as_int(),
        payload1.address.7.reinterpret_as_int(),
        payload1.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketStartConnect(
    handle, handle0, lowered, lowered2, lowered3, lowered4, lowered5, lowered6, lowered7,
    lowered8, lowered9, lowered10, lowered11, lowered12, return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_connect(
  self : TcpSocket,
) -> Result[(@streams.InputStream, @streams.OutputStream), @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodTcpSocketFinishConnect(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          @streams.InputStream::InputStream(mbt_ffi_load32(return_area + 4)),
          @streams.OutputStream::OutputStream(mbt_ffi_load32(return_area + 8)),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::start_listen(
  self : TcpSocket,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketStartListen(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::finish_listen(
  self : TcpSocket,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketFinishListen(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::accept(
  self : TcpSocket,
) -> Result[
  (TcpSocket, @streams.InputStream, @streams.OutputStream),
  @network.ErrorCode,
] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodTcpSocketAccept(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          TcpSocket::TcpSocket(mbt_ffi_load32(return_area + 4)),
          @streams.InputStream::InputStream(mbt_ffi_load32(return_area + 8)),
          @streams.OutputStream::OutputStream(mbt_ffi_load32(return_area + 12)),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::local_address(
  self : TcpSocket,
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(36)
  wasmImportMethodTcpSocketLocalAddress(handle, return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              mbt_ffi_load8_u(return_area + 10).to_byte(),
              mbt_ffi_load8_u(return_area + 11).to_byte(),
              mbt_ffi_load8_u(return_area + 12).to_byte(),
              mbt_ffi_load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: mbt_ffi_load32(return_area + 12).reinterpret_as_uint(),
            address: (
              mbt_ffi_load16_u(return_area + 16)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 18)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 20)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 22)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 24)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 26)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 28)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 30)
              .land(0xFFFF)
              .reinterpret_as_uint(),
            ),
            scope_id: mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn TcpSocket::remote_address(
  self : TcpSocket,
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(36)
  wasmImportMethodTcpSocketRemoteAddress(handle, return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              mbt_ffi_load8_u(return_area + 10).to_byte(),
              mbt_ffi_load8_u(return_area + 11).to_byte(),
              mbt_ffi_load8_u(return_area + 12).to_byte(),
              mbt_ffi_load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: mbt_ffi_load32(return_area + 12).reinterpret_as_uint(),
            address: (
              mbt_ffi_load16_u(return_area + 16)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 18)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 20)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 22)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 24)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 26)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 28)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 30)
              .land(0xFFFF)
              .reinterpret_as_uint(),
            ),
            scope_id: mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn TcpSocket::is_listening(self : TcpSocket) -> Bool {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketIsListening(handle)
  return result != 0
}

///|
pub fn TcpSocket::address_family(self : TcpSocket) -> @network.IpAddressFamily {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketAddressFamily(handle)
  return @network.IpAddressFamily::from(result)
}

///|
pub fn TcpSocket::set_listen_backlog_size(
  self : TcpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetListenBacklogSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::keep_alive_enabled(
  self : TcpSocket,
) -> Result[Bool, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketKeepAliveEnabled(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load8_u(return_area + 1) != 0)
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_enabled(
  self : TcpSocket,
  value : Bool,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveEnabled(
    handle,
    if value {
      1
    } else {
      0
    },
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::keep_alive_idle_time(
  self : TcpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodTcpSocketKeepAliveIdleTime(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_idle_time(
  self : TcpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveIdleTime(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::keep_alive_interval(
  self : TcpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodTcpSocketKeepAliveInterval(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_interval(
  self : TcpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveInterval(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::keep_alive_count(
  self : TcpSocket,
) -> Result[UInt, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodTcpSocketKeepAliveCount(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load32(return_area + 4).reinterpret_as_uint())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_keep_alive_count(
  self : TcpSocket,
  value : UInt,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetKeepAliveCount(
    handle,
    value.reinterpret_as_int(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::hop_limit(
  self : TcpSocket,
) -> Result[Byte, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketHopLimit(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load8_u(return_area + 1).to_byte())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_hop_limit(
  self : TcpSocket,
  value : Byte,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetHopLimit(handle, value.to_int(), return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::receive_buffer_size(
  self : TcpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodTcpSocketReceiveBufferSize(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_receive_buffer_size(
  self : TcpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetReceiveBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::send_buffer_size(
  self : TcpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodTcpSocketSendBufferSize(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::set_send_buffer_size(
  self : TcpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketSetSendBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn TcpSocket::subscribe(self : TcpSocket) -> @poll.Pollable {
  let TcpSocket(handle) = self
  let result : Int = wasmImportMethodTcpSocketSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///|
pub fn TcpSocket::shutdown(
  self : TcpSocket,
  shutdown_type : ShutdownType,
) -> Result[Unit, @network.ErrorCode] {
  let TcpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodTcpSocketShutdown(
    handle,
    shutdown_type.ordinal(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}
