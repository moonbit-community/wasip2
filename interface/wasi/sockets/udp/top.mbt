// Generated by `wit-bindgen` 0.49.0. DO NOT EDIT!

///|
pub(all) struct IncomingDatagram {
  data : FixedArray[Byte]
  remote_address : @network.IpSocketAddress
} derive(Show, Eq)

///|
pub(all) struct OutgoingDatagram {
  data : FixedArray[Byte]
  remote_address : @network.IpSocketAddress?
} derive(Show, Eq)

///|
pub(all) struct UdpSocket(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn UdpSocket::drop(self : UdpSocket) -> Unit {
  let UdpSocket(resource) = self
  wasmImportResourceDropUdpSocket(resource)
}

///|
pub(all) struct IncomingDatagramStream(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn IncomingDatagramStream::drop(self : IncomingDatagramStream) -> Unit {
  let IncomingDatagramStream(resource) = self
  wasmImportResourceDropIncomingDatagramStream(resource)
}

///|
pub(all) struct OutgoingDatagramStream(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn OutgoingDatagramStream::drop(self : OutgoingDatagramStream) -> Unit {
  let OutgoingDatagramStream(resource) = self
  wasmImportResourceDropOutgoingDatagramStream(resource)
}

///|
pub fn UdpSocket::start_bind(
  self : UdpSocket,
  network : @network.Network,
  local_address : @network.IpSocketAddress,
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let @network.Network(handle0) = network
  let (
    lowered,
    lowered2,
    lowered3,
    lowered4,
    lowered5,
    lowered6,
    lowered7,
    lowered8,
    lowered9,
    lowered10,
    lowered11,
    lowered12,
  ) = match local_address {
    Ipv4(payload) =>
      (
        0,
        payload.port.reinterpret_as_int(),
        payload.address.0.to_int(),
        payload.address.1.to_int(),
        payload.address.2.to_int(),
        payload.address.3.to_int(),
        0,
        0,
        0,
        0,
        0,
        0,
      )
    Ipv6(payload1) =>
      (
        1,
        payload1.port.reinterpret_as_int(),
        payload1.flow_info.reinterpret_as_int(),
        payload1.address.0.reinterpret_as_int(),
        payload1.address.1.reinterpret_as_int(),
        payload1.address.2.reinterpret_as_int(),
        payload1.address.3.reinterpret_as_int(),
        payload1.address.4.reinterpret_as_int(),
        payload1.address.5.reinterpret_as_int(),
        payload1.address.6.reinterpret_as_int(),
        payload1.address.7.reinterpret_as_int(),
        payload1.scope_id.reinterpret_as_int(),
      )
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketStartBind(
    handle, handle0, lowered, lowered2, lowered3, lowered4, lowered5, lowered6, lowered7,
    lowered8, lowered9, lowered10, lowered11, lowered12, return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::finish_bind(
  self : UdpSocket,
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketFinishBind(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::stream(
  self : UdpSocket,
  remote_address : @network.IpSocketAddress?,
) -> Result[
  (IncomingDatagramStream, OutgoingDatagramStream),
  @network.ErrorCode,
] {
  let UdpSocket(handle) = self
  let (
    lowered14,
    lowered15,
    lowered16,
    lowered17,
    lowered18,
    lowered19,
    lowered20,
    lowered21,
    lowered22,
    lowered23,
    lowered24,
    lowered25,
    lowered26,
  ) = match remote_address {
    None => (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    Some(payload0) => {
      let (
        lowered,
        lowered3,
        lowered4,
        lowered5,
        lowered6,
        lowered7,
        lowered8,
        lowered9,
        lowered10,
        lowered11,
        lowered12,
        lowered13,
      ) = match payload0 {
        Ipv4(payload1) =>
          (
            0,
            payload1.port.reinterpret_as_int(),
            payload1.address.0.to_int(),
            payload1.address.1.to_int(),
            payload1.address.2.to_int(),
            payload1.address.3.to_int(),
            0,
            0,
            0,
            0,
            0,
            0,
          )
        Ipv6(payload2) =>
          (
            1,
            payload2.port.reinterpret_as_int(),
            payload2.flow_info.reinterpret_as_int(),
            payload2.address.0.reinterpret_as_int(),
            payload2.address.1.reinterpret_as_int(),
            payload2.address.2.reinterpret_as_int(),
            payload2.address.3.reinterpret_as_int(),
            payload2.address.4.reinterpret_as_int(),
            payload2.address.5.reinterpret_as_int(),
            payload2.address.6.reinterpret_as_int(),
            payload2.address.7.reinterpret_as_int(),
            payload2.scope_id.reinterpret_as_int(),
          )
      }
      (
        1, lowered, lowered3, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9,
        lowered10, lowered11, lowered12, lowered13,
      )
    }
  }
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodUdpSocketStream(
    handle, lowered14, lowered15, lowered16, lowered17, lowered18, lowered19, lowered20,
    lowered21, lowered22, lowered23, lowered24, lowered25, lowered26, return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        (
          IncomingDatagramStream::IncomingDatagramStream(
            mbt_ffi_load32(return_area + 4),
          ),
          OutgoingDatagramStream::OutgoingDatagramStream(
            mbt_ffi_load32(return_area + 8),
          ),
        ),
      )
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::local_address(
  self : UdpSocket,
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(36)
  wasmImportMethodUdpSocketLocalAddress(handle, return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              mbt_ffi_load8_u(return_area + 10).to_byte(),
              mbt_ffi_load8_u(return_area + 11).to_byte(),
              mbt_ffi_load8_u(return_area + 12).to_byte(),
              mbt_ffi_load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: mbt_ffi_load32(return_area + 12).reinterpret_as_uint(),
            address: (
              mbt_ffi_load16_u(return_area + 16)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 18)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 20)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 22)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 24)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 26)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 28)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 30)
              .land(0xFFFF)
              .reinterpret_as_uint(),
            ),
            scope_id: mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn UdpSocket::remote_address(
  self : UdpSocket,
) -> Result[@network.IpSocketAddress, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(36)
  wasmImportMethodUdpSocketRemoteAddress(handle, return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted = match mbt_ffi_load8_u(return_area + 4) {
        0 =>
          @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            address: (
              mbt_ffi_load8_u(return_area + 10).to_byte(),
              mbt_ffi_load8_u(return_area + 11).to_byte(),
              mbt_ffi_load8_u(return_area + 12).to_byte(),
              mbt_ffi_load8_u(return_area + 13).to_byte(),
            ),
          })
        1 =>
          @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
            port: mbt_ffi_load16_u(return_area + 8)
            .land(0xFFFF)
            .reinterpret_as_uint(),
            flow_info: mbt_ffi_load32(return_area + 12).reinterpret_as_uint(),
            address: (
              mbt_ffi_load16_u(return_area + 16)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 18)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 20)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 22)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 24)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 26)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 28)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              mbt_ffi_load16_u(return_area + 30)
              .land(0xFFFF)
              .reinterpret_as_uint(),
            ),
            scope_id: mbt_ffi_load32(return_area + 32).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn UdpSocket::address_family(self : UdpSocket) -> @network.IpAddressFamily {
  let UdpSocket(handle) = self
  let result : Int = wasmImportMethodUdpSocketAddressFamily(handle)
  return @network.IpAddressFamily::from(result)
}

///|
pub fn UdpSocket::unicast_hop_limit(
  self : UdpSocket,
) -> Result[Byte, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketUnicastHopLimit(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load8_u(return_area + 1).to_byte())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_unicast_hop_limit(
  self : UdpSocket,
  value : Byte,
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketSetUnicastHopLimit(
    handle,
    value.to_int(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::receive_buffer_size(
  self : UdpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodUdpSocketReceiveBufferSize(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_receive_buffer_size(
  self : UdpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketSetReceiveBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::send_buffer_size(
  self : UdpSocket,
) -> Result[UInt64, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodUdpSocketSendBufferSize(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::set_send_buffer_size(
  self : UdpSocket,
  value : UInt64,
) -> Result[Unit, @network.ErrorCode] {
  let UdpSocket(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodUdpSocketSetSendBufferSize(
    handle,
    value.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn UdpSocket::subscribe(self : UdpSocket) -> @poll.Pollable {
  let UdpSocket(handle) = self
  let result : Int = wasmImportMethodUdpSocketSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///|
pub fn IncomingDatagramStream::receive(
  self : IncomingDatagramStream,
  max_results : UInt64,
) -> Result[Array[IncomingDatagram], @network.ErrorCode] {
  let IncomingDatagramStream(handle) = self
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodIncomingDatagramStreamReceive(
    handle,
    max_results.reinterpret_as_int64(),
    return_area,
  )
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let array : Array[IncomingDatagram] = []
      for index = 0; index < mbt_ffi_load32(return_area + 8); index = index + 1 {
        let iter_base = mbt_ffi_load32(return_area + 4) + index * 40
        let result = mbt_ffi_ptr2bytes(
          mbt_ffi_load32(iter_base + 0),
          mbt_ffi_load32(iter_base + 4),
        )
        let lifted = match mbt_ffi_load8_u(iter_base + 8) {
          0 =>
            @network.IpSocketAddress::Ipv4(@network.Ipv4SocketAddress::{
              port: mbt_ffi_load16_u(iter_base + 12)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              address: (
                mbt_ffi_load8_u(iter_base + 14).to_byte(),
                mbt_ffi_load8_u(iter_base + 15).to_byte(),
                mbt_ffi_load8_u(iter_base + 16).to_byte(),
                mbt_ffi_load8_u(iter_base + 17).to_byte(),
              ),
            })
          1 =>
            @network.IpSocketAddress::Ipv6(@network.Ipv6SocketAddress::{
              port: mbt_ffi_load16_u(iter_base + 12)
              .land(0xFFFF)
              .reinterpret_as_uint(),
              flow_info: mbt_ffi_load32(iter_base + 16).reinterpret_as_uint(),
              address: (
                mbt_ffi_load16_u(iter_base + 20)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 22)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 24)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 26)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 28)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 32)
                .land(0xFFFF)
                .reinterpret_as_uint(),
                mbt_ffi_load16_u(iter_base + 34)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              ),
              scope_id: mbt_ffi_load32(iter_base + 36).reinterpret_as_uint(),
            })
          _ => panic()
        }
        array.push(IncomingDatagram::{ data: result, remote_address: lifted })
      }
      mbt_ffi_free(mbt_ffi_load32(return_area + 4))
      Result::Ok(array)
    }
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn IncomingDatagramStream::subscribe(
  self : IncomingDatagramStream,
) -> @poll.Pollable {
  let IncomingDatagramStream(handle) = self
  let result : Int = wasmImportMethodIncomingDatagramStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///|
pub fn OutgoingDatagramStream::check_send(
  self : OutgoingDatagramStream,
) -> Result[UInt64, @network.ErrorCode] {
  let OutgoingDatagramStream(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodOutgoingDatagramStreamCheckSend(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn OutgoingDatagramStream::send(
  self : OutgoingDatagramStream,
  datagrams : Array[OutgoingDatagram],
) -> Result[UInt64, @network.ErrorCode] {
  let cleanup_list : Array[Int] = []
  let OutgoingDatagramStream(handle) = self
  let address = mbt_ffi_malloc(datagrams.length() * 44)
  for index = 0; index < datagrams.length(); index = index + 1 {
    let iter_elem : OutgoingDatagram = datagrams[index]
    let iter_base = address + index * 44
    let ptr = mbt_ffi_bytes2ptr(iter_elem.data)
    mbt_ffi_store32(iter_base + 4, iter_elem.data.length())
    mbt_ffi_store32(iter_base + 0, ptr)
    match iter_elem.remote_address {
      None => {
        mbt_ffi_store8(iter_base + 8, 0)
        ()
      }
      Some(payload0) => {
        mbt_ffi_store8(iter_base + 8, 1)
        match payload0 {
          Ipv4(payload1) => {
            mbt_ffi_store8(iter_base + 12, 0)
            mbt_ffi_store16(iter_base + 16, payload1.port.reinterpret_as_int())
            mbt_ffi_store8(iter_base + 18, payload1.address.0.to_int())
            mbt_ffi_store8(iter_base + 19, payload1.address.1.to_int())
            mbt_ffi_store8(iter_base + 20, payload1.address.2.to_int())
            mbt_ffi_store8(iter_base + 21, payload1.address.3.to_int())
            ()
          }
          Ipv6(payload2) => {
            mbt_ffi_store8(iter_base + 12, 1)
            mbt_ffi_store16(iter_base + 16, payload2.port.reinterpret_as_int())
            mbt_ffi_store32(
              iter_base + 20,
              payload2.flow_info.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 24,
              payload2.address.0.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 26,
              payload2.address.1.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 28,
              payload2.address.2.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 30,
              payload2.address.3.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 32,
              payload2.address.4.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 34,
              payload2.address.5.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 36,
              payload2.address.6.reinterpret_as_int(),
            )
            mbt_ffi_store16(
              iter_base + 38,
              payload2.address.7.reinterpret_as_int(),
            )
            mbt_ffi_store32(
              iter_base + 40,
              payload2.scope_id.reinterpret_as_int(),
            )
            ()
          }
        }
        ()
      }
    }
    mbt_ffi_free(ptr)
  }
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodOutgoingDatagramStreamSend(
    handle,
    address,
    datagrams.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@network.ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(address)
  mbt_ffi_free(return_area)
  cleanup_list.each(mbt_ffi_free)
  return lifted
}

///|
pub fn OutgoingDatagramStream::subscribe(
  self : OutgoingDatagramStream,
) -> @poll.Pollable {
  let OutgoingDatagramStream(handle) = self
  let result : Int = wasmImportMethodOutgoingDatagramStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}
