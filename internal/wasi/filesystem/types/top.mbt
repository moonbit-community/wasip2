// Generated by `wit-bindgen` 0.49.0. DO NOT EDIT!

///|
pub(all) enum DescriptorType {
  UNKNOWN
  BLOCK_DEVICE
  CHARACTER_DEVICE
  DIRECTORY
  FIFO
  SYMBOLIC_LINK
  REGULAR_FILE
  SOCKET
} derive(Show, Eq)

///|
pub fn DescriptorType::ordinal(self : DescriptorType) -> Int {
  match self {
    UNKNOWN => 0
    BLOCK_DEVICE => 1
    CHARACTER_DEVICE => 2
    DIRECTORY => 3
    FIFO => 4
    SYMBOLIC_LINK => 5
    REGULAR_FILE => 6
    SOCKET => 7
  }
}

///|
pub fn DescriptorType::from(self : Int) -> DescriptorType {
  match self {
    0 => UNKNOWN
    1 => BLOCK_DEVICE
    2 => CHARACTER_DEVICE
    3 => DIRECTORY
    4 => FIFO
    5 => SYMBOLIC_LINK
    6 => REGULAR_FILE
    7 => SOCKET
    _ => panic()
  }
}

///|
pub(all) struct DescriptorFlags(Byte) derive(Show, Eq)

///|
pub fn DescriptorFlags::default() -> DescriptorFlags {
  b'\x00'
}

///|
pub(all) enum DescriptorFlagsFlag {
  READ
  WRITE
  FILE_INTEGRITY_SYNC
  DATA_INTEGRITY_SYNC
  REQUESTED_WRITE_SYNC
  MUTATE_DIRECTORY
}

///|
fn DescriptorFlagsFlag::value(self : DescriptorFlagsFlag) -> Byte {
  match self {
    READ => (1U << 0).to_byte()
    WRITE => (1U << 1).to_byte()
    FILE_INTEGRITY_SYNC => (1U << 2).to_byte()
    DATA_INTEGRITY_SYNC => (1U << 3).to_byte()
    REQUESTED_WRITE_SYNC => (1U << 4).to_byte()
    MUTATE_DIRECTORY => (1U << 5).to_byte()
  }
}

///|
pub fn DescriptorFlags::set(
  self : Self,
  other : DescriptorFlagsFlag,
) -> DescriptorFlags {
  let DescriptorFlags(flag) = self
  flag | other.value()
}

///|
pub fn DescriptorFlags::unset(
  self : Self,
  other : DescriptorFlagsFlag,
) -> DescriptorFlags {
  let DescriptorFlags(flag) = self
  flag & other.value().lnot()
}

///|
pub fn DescriptorFlags::is_set(
  self : Self,
  other : DescriptorFlagsFlag,
) -> Bool {
  let DescriptorFlags(flag) = self
  (flag & other.value()) == other.value()
}

///|
pub(all) struct PathFlags(Byte) derive(Show, Eq)

///|
pub fn PathFlags::default() -> PathFlags {
  b'\x00'
}

///|
pub(all) enum PathFlagsFlag {
  SYMLINK_FOLLOW
}

///|
fn PathFlagsFlag::value(self : PathFlagsFlag) -> Byte {
  match self {
    SYMLINK_FOLLOW => (1U << 0).to_byte()
  }
}

///|
pub fn PathFlags::set(self : Self, other : PathFlagsFlag) -> PathFlags {
  let PathFlags(flag) = self
  flag | other.value()
}

///|
pub fn PathFlags::unset(self : Self, other : PathFlagsFlag) -> PathFlags {
  let PathFlags(flag) = self
  flag & other.value().lnot()
}

///|
pub fn PathFlags::is_set(self : Self, other : PathFlagsFlag) -> Bool {
  let PathFlags(flag) = self
  (flag & other.value()) == other.value()
}

///|
pub(all) struct OpenFlags(Byte) derive(Show, Eq)

///|
pub fn OpenFlags::default() -> OpenFlags {
  b'\x00'
}

///|
pub(all) enum OpenFlagsFlag {
  CREATE
  DIRECTORY
  EXCLUSIVE
  TRUNCATE
}

///|
fn OpenFlagsFlag::value(self : OpenFlagsFlag) -> Byte {
  match self {
    CREATE => (1U << 0).to_byte()
    DIRECTORY => (1U << 1).to_byte()
    EXCLUSIVE => (1U << 2).to_byte()
    TRUNCATE => (1U << 3).to_byte()
  }
}

///|
pub fn OpenFlags::set(self : Self, other : OpenFlagsFlag) -> OpenFlags {
  let OpenFlags(flag) = self
  flag | other.value()
}

///|
pub fn OpenFlags::unset(self : Self, other : OpenFlagsFlag) -> OpenFlags {
  let OpenFlags(flag) = self
  flag & other.value().lnot()
}

///|
pub fn OpenFlags::is_set(self : Self, other : OpenFlagsFlag) -> Bool {
  let OpenFlags(flag) = self
  (flag & other.value()) == other.value()
}

///|
pub(all) struct DescriptorStat {
  type_ : DescriptorType
  link_count : UInt64
  size : UInt64
  data_access_timestamp : @wallClock.Datetime?
  data_modification_timestamp : @wallClock.Datetime?
  status_change_timestamp : @wallClock.Datetime?
} derive(Show, Eq)

///|
pub(all) enum NewTimestamp {
  NoChange
  Now
  Timestamp(@wallClock.Datetime)
} derive(Show, Eq)

///|
pub(all) struct DirectoryEntry {
  type_ : DescriptorType
  name : String
} derive(Show, Eq)

///|
pub(all) suberror ErrorCode {
  ACCESS
  WOULD_BLOCK
  ALREADY
  BAD_DESCRIPTOR
  BUSY
  DEADLOCK
  QUOTA
  EXIST
  FILE_TOO_LARGE
  ILLEGAL_BYTE_SEQUENCE
  IN_PROGRESS
  INTERRUPTED
  INVALID
  IO
  IS_DIRECTORY
  LOOP
  TOO_MANY_LINKS
  MESSAGE_SIZE
  NAME_TOO_LONG
  NO_DEVICE
  NO_ENTRY
  NO_LOCK
  INSUFFICIENT_MEMORY
  INSUFFICIENT_SPACE
  NOT_DIRECTORY
  NOT_EMPTY
  NOT_RECOVERABLE
  UNSUPPORTED
  NO_TTY
  NO_SUCH_DEVICE
  OVERFLOW
  NOT_PERMITTED
  PIPE
  READ_ONLY
  INVALID_SEEK
  TEXT_FILE_BUSY
  CROSS_DEVICE
} derive(Show, Eq)

///|
pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
  match self {
    ACCESS => 0
    WOULD_BLOCK => 1
    ALREADY => 2
    BAD_DESCRIPTOR => 3
    BUSY => 4
    DEADLOCK => 5
    QUOTA => 6
    EXIST => 7
    FILE_TOO_LARGE => 8
    ILLEGAL_BYTE_SEQUENCE => 9
    IN_PROGRESS => 10
    INTERRUPTED => 11
    INVALID => 12
    IO => 13
    IS_DIRECTORY => 14
    LOOP => 15
    TOO_MANY_LINKS => 16
    MESSAGE_SIZE => 17
    NAME_TOO_LONG => 18
    NO_DEVICE => 19
    NO_ENTRY => 20
    NO_LOCK => 21
    INSUFFICIENT_MEMORY => 22
    INSUFFICIENT_SPACE => 23
    NOT_DIRECTORY => 24
    NOT_EMPTY => 25
    NOT_RECOVERABLE => 26
    UNSUPPORTED => 27
    NO_TTY => 28
    NO_SUCH_DEVICE => 29
    OVERFLOW => 30
    NOT_PERMITTED => 31
    PIPE => 32
    READ_ONLY => 33
    INVALID_SEEK => 34
    TEXT_FILE_BUSY => 35
    CROSS_DEVICE => 36
  }
}

///|
pub fn ErrorCode::from(self : Int) -> ErrorCode {
  match self {
    0 => ACCESS
    1 => WOULD_BLOCK
    2 => ALREADY
    3 => BAD_DESCRIPTOR
    4 => BUSY
    5 => DEADLOCK
    6 => QUOTA
    7 => EXIST
    8 => FILE_TOO_LARGE
    9 => ILLEGAL_BYTE_SEQUENCE
    10 => IN_PROGRESS
    11 => INTERRUPTED
    12 => INVALID
    13 => IO
    14 => IS_DIRECTORY
    15 => LOOP
    16 => TOO_MANY_LINKS
    17 => MESSAGE_SIZE
    18 => NAME_TOO_LONG
    19 => NO_DEVICE
    20 => NO_ENTRY
    21 => NO_LOCK
    22 => INSUFFICIENT_MEMORY
    23 => INSUFFICIENT_SPACE
    24 => NOT_DIRECTORY
    25 => NOT_EMPTY
    26 => NOT_RECOVERABLE
    27 => UNSUPPORTED
    28 => NO_TTY
    29 => NO_SUCH_DEVICE
    30 => OVERFLOW
    31 => NOT_PERMITTED
    32 => PIPE
    33 => READ_ONLY
    34 => INVALID_SEEK
    35 => TEXT_FILE_BUSY
    36 => CROSS_DEVICE
    _ => panic()
  }
}

///|
pub(all) enum Advice {
  NORMAL
  SEQUENTIAL
  RANDOM
  WILL_NEED
  DONT_NEED
  NO_REUSE
} derive(Show, Eq)

///|
pub fn Advice::ordinal(self : Advice) -> Int {
  match self {
    NORMAL => 0
    SEQUENTIAL => 1
    RANDOM => 2
    WILL_NEED => 3
    DONT_NEED => 4
    NO_REUSE => 5
  }
}

///|
pub fn Advice::from(self : Int) -> Advice {
  match self {
    0 => NORMAL
    1 => SEQUENTIAL
    2 => RANDOM
    3 => WILL_NEED
    4 => DONT_NEED
    5 => NO_REUSE
    _ => panic()
  }
}

///|
pub(all) struct MetadataHashValue {
  lower : UInt64
  upper : UInt64
} derive(Show, Eq)

///|
pub(all) struct Descriptor(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn Descriptor::drop(self : Descriptor) -> Unit {
  let Descriptor(resource) = self
  wasmImportResourceDropDescriptor(resource)
}

///|
pub(all) struct DirectoryEntryStream(Int) derive(Show, Eq)

///|
/// Drops a resource handle.
pub fn DirectoryEntryStream::drop(self : DirectoryEntryStream) -> Unit {
  let DirectoryEntryStream(resource) = self
  wasmImportResourceDropDirectoryEntryStream(resource)
}

///|
pub fn Descriptor::read_via_stream(
  self : Descriptor,
  offset : UInt64,
) -> Result[@streams.InputStream, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodDescriptorReadViaStream(
    handle,
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.InputStream::InputStream(mbt_ffi_load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::write_via_stream(
  self : Descriptor,
  offset : UInt64,
) -> Result[@streams.OutputStream, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodDescriptorWriteViaStream(
    handle,
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(mbt_ffi_load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::append_via_stream(
  self : Descriptor,
) -> Result[@streams.OutputStream, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodDescriptorAppendViaStream(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(mbt_ffi_load32(return_area + 4)),
      )
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::advise(
  self : Descriptor,
  offset : UInt64,
  length : UInt64,
  advice : Advice,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorAdvise(
    handle,
    offset.reinterpret_as_int64(),
    length.reinterpret_as_int64(),
    advice.ordinal(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::sync_data(self : Descriptor) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSyncData(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::get_flags(
  self : Descriptor,
) -> Result[DescriptorFlags, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorGetFlags(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(DescriptorFlags(mbt_ffi_load8_u(return_area + 1).to_byte()))
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::get_type(
  self : Descriptor,
) -> Result[DescriptorType, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorGetType(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(DescriptorType::from(mbt_ffi_load8_u(return_area + 1)))
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::set_size(
  self : Descriptor,
  size : UInt64,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSetSize(
    handle,
    size.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::set_times(
  self : Descriptor,
  data_access_timestamp : NewTimestamp,
  data_modification_timestamp : NewTimestamp,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let (lowered, lowered2, lowered3) = match data_access_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload1) =>
      (
        2,
        payload1.seconds.reinterpret_as_int64(),
        payload1.nanoseconds.reinterpret_as_int(),
      )
  }
  let (lowered7, lowered8, lowered9) = match data_modification_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload6) =>
      (
        2,
        payload6.seconds.reinterpret_as_int64(),
        payload6.nanoseconds.reinterpret_as_int(),
      )
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSetTimes(
    handle, lowered, lowered2, lowered3, lowered7, lowered8, lowered9, return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::read(
  self : Descriptor,
  length : UInt64,
  offset : UInt64,
) -> Result[(FixedArray[Byte], Bool), ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodDescriptorRead(
    handle,
    length.reinterpret_as_int64(),
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let result = mbt_ffi_ptr2bytes(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Result::Ok((result, mbt_ffi_load8_u(return_area + 12) != 0))
    }
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::write(
  self : Descriptor,
  buffer : FixedArray[Byte],
  offset : UInt64,
) -> Result[UInt64, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_bytes2ptr(buffer)
  let return_area = mbt_ffi_malloc(16)
  wasmImportMethodDescriptorWrite(
    handle,
    ptr,
    buffer.length(),
    offset.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(mbt_ffi_load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::read_directory(
  self : Descriptor,
) -> Result[DirectoryEntryStream, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodDescriptorReadDirectory(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        DirectoryEntryStream::DirectoryEntryStream(
          mbt_ffi_load32(return_area + 4),
        ),
      )
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::sync(self : Descriptor) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSync(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::create_directory_at(
  self : Descriptor,
  path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorCreateDirectoryAt(
    handle,
    ptr,
    path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::stat(self : Descriptor) -> Result[DescriptorStat, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(104)
  wasmImportMethodDescriptorStat(handle, return_area)
  let lifted2 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 32) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted0 : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 56) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 64).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 72).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted1 : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 80) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 88).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 96).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(DescriptorStat::{
        type_: DescriptorType::from(mbt_ffi_load8_u(return_area + 8)),
        link_count: mbt_ffi_load64(return_area + 16).reinterpret_as_uint64(),
        size: mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
        data_access_timestamp: lifted,
        data_modification_timestamp: lifted0,
        status_change_timestamp: lifted1,
      })
    }
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted2
}

///|
pub fn Descriptor::stat_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
) -> Result[DescriptorStat, ErrorCode] {
  let Descriptor(handle) = self
  let PathFlags(flag) = path_flags
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(104)
  wasmImportMethodDescriptorStatAt(
    handle,
    flag.to_int(),
    ptr,
    path.length(),
    return_area,
  )
  let lifted2 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 32) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 40).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 48).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted0 : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 56) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 64).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 72).reinterpret_as_uint(),
          })
        _ => panic()
      }
      let lifted1 : @wallClock.Datetime? = match
        mbt_ffi_load8_u(return_area + 80) {
        0 => Option::None
        1 =>
          Option::Some(@wallClock.Datetime::{
            seconds: mbt_ffi_load64(return_area + 88).reinterpret_as_uint64(),
            nanoseconds: mbt_ffi_load32(return_area + 96).reinterpret_as_uint(),
          })
        _ => panic()
      }
      Result::Ok(DescriptorStat::{
        type_: DescriptorType::from(mbt_ffi_load8_u(return_area + 8)),
        link_count: mbt_ffi_load64(return_area + 16).reinterpret_as_uint64(),
        size: mbt_ffi_load64(return_area + 24).reinterpret_as_uint64(),
        data_access_timestamp: lifted,
        data_modification_timestamp: lifted0,
        status_change_timestamp: lifted1,
      })
    }
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted2
}

///|
pub fn Descriptor::set_times_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
  data_access_timestamp : NewTimestamp,
  data_modification_timestamp : NewTimestamp,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let PathFlags(flag) = path_flags
  let ptr = mbt_ffi_str2ptr(path)
  let (lowered, lowered2, lowered3) = match data_access_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload1) =>
      (
        2,
        payload1.seconds.reinterpret_as_int64(),
        payload1.nanoseconds.reinterpret_as_int(),
      )
  }
  let (lowered7, lowered8, lowered9) = match data_modification_timestamp {
    NoChange => (0, 0L, 0)
    Now => (1, 0L, 0)
    Timestamp(payload6) =>
      (
        2,
        payload6.seconds.reinterpret_as_int64(),
        payload6.nanoseconds.reinterpret_as_int(),
      )
  }
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSetTimesAt(
    handle,
    flag.to_int(),
    ptr,
    path.length(),
    lowered,
    lowered2,
    lowered3,
    lowered7,
    lowered8,
    lowered9,
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::link_at(
  self : Descriptor,
  old_path_flags : PathFlags,
  old_path : String,
  new_descriptor : Descriptor,
  new_path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let PathFlags(flag) = old_path_flags
  let ptr = mbt_ffi_str2ptr(old_path)
  let Descriptor(handle0) = new_descriptor
  let ptr1 = mbt_ffi_str2ptr(new_path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorLinkAt(
    handle,
    flag.to_int(),
    ptr,
    old_path.length(),
    handle0,
    ptr1,
    new_path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(ptr1)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::open_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
  open_flags : OpenFlags,
  flags : DescriptorFlags,
) -> Result[Descriptor, ErrorCode] {
  let Descriptor(handle) = self
  let PathFlags(flag) = path_flags
  let ptr = mbt_ffi_str2ptr(path)
  let OpenFlags(flag0) = open_flags
  let DescriptorFlags(flag1) = flags
  let return_area = mbt_ffi_malloc(8)
  wasmImportMethodDescriptorOpenAt(
    handle,
    flag.to_int(),
    ptr,
    path.length(),
    flag0.to_int(),
    flag1.to_int(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(Descriptor::Descriptor(mbt_ffi_load32(return_area + 4)))
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::readlink_at(
  self : Descriptor,
  path : String,
) -> Result[String, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(12)
  wasmImportMethodDescriptorReadlinkAt(handle, ptr, path.length(), return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let result = mbt_ffi_ptr2str(
        mbt_ffi_load32(return_area + 4),
        mbt_ffi_load32(return_area + 8),
      )
      Result::Ok(result)
    }
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::remove_directory_at(
  self : Descriptor,
  path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorRemoveDirectoryAt(
    handle,
    ptr,
    path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::rename_at(
  self : Descriptor,
  old_path : String,
  new_descriptor : Descriptor,
  new_path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(old_path)
  let Descriptor(handle0) = new_descriptor
  let ptr1 = mbt_ffi_str2ptr(new_path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorRenameAt(
    handle,
    ptr,
    old_path.length(),
    handle0,
    ptr1,
    new_path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(ptr1)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::symlink_at(
  self : Descriptor,
  old_path : String,
  new_path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(old_path)
  let ptr0 = mbt_ffi_str2ptr(new_path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorSymlinkAt(
    handle,
    ptr,
    old_path.length(),
    ptr0,
    new_path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(ptr0)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::unlink_file_at(
  self : Descriptor,
  path : String,
) -> Result[Unit, ErrorCode] {
  let Descriptor(handle) = self
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(2)
  wasmImportMethodDescriptorUnlinkFileAt(
    handle,
    ptr,
    path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::is_same_object(
  self : Descriptor,
  other : Descriptor,
) -> Bool {
  let Descriptor(handle) = self
  let Descriptor(handle0) = other
  let result : Int = wasmImportMethodDescriptorIsSameObject(handle, handle0)
  return result != 0
}

///|
pub fn Descriptor::metadata_hash(
  self : Descriptor,
) -> Result[MetadataHashValue, ErrorCode] {
  let Descriptor(handle) = self
  let return_area = mbt_ffi_malloc(24)
  wasmImportMethodDescriptorMetadataHash(handle, return_area)
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(MetadataHashValue::{
        lower: mbt_ffi_load64(return_area + 8).reinterpret_as_uint64(),
        upper: mbt_ffi_load64(return_area + 16).reinterpret_as_uint64(),
      })
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn Descriptor::metadata_hash_at(
  self : Descriptor,
  path_flags : PathFlags,
  path : String,
) -> Result[MetadataHashValue, ErrorCode] {
  let Descriptor(handle) = self
  let PathFlags(flag) = path_flags
  let ptr = mbt_ffi_str2ptr(path)
  let return_area = mbt_ffi_malloc(24)
  wasmImportMethodDescriptorMetadataHashAt(
    handle,
    flag.to_int(),
    ptr,
    path.length(),
    return_area,
  )
  let lifted = match mbt_ffi_load8_u(return_area + 0) {
    0 =>
      Result::Ok(MetadataHashValue::{
        lower: mbt_ffi_load64(return_area + 8).reinterpret_as_uint64(),
        upper: mbt_ffi_load64(return_area + 16).reinterpret_as_uint64(),
      })
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 8)))
    _ => panic()
  }
  mbt_ffi_free(ptr)
  mbt_ffi_free(return_area)
  return lifted
}

///|
pub fn DirectoryEntryStream::read_directory_entry(
  self : DirectoryEntryStream,
) -> Result[DirectoryEntry?, ErrorCode] {
  let DirectoryEntryStream(handle) = self
  let return_area = mbt_ffi_malloc(20)
  wasmImportMethodDirectoryEntryStreamReadDirectoryEntry(handle, return_area)
  let lifted0 = match mbt_ffi_load8_u(return_area + 0) {
    0 => {
      let lifted : DirectoryEntry? = match mbt_ffi_load8_u(return_area + 4) {
        0 => Option::None
        1 => {
          let result = mbt_ffi_ptr2str(
            mbt_ffi_load32(return_area + 12),
            mbt_ffi_load32(return_area + 16),
          )
          Option::Some(DirectoryEntry::{
            type_: DescriptorType::from(mbt_ffi_load8_u(return_area + 8)),
            name: result,
          })
        }
        _ => panic()
      }
      Result::Ok(lifted)
    }
    1 => Result::Err(ErrorCode::from(mbt_ffi_load8_u(return_area + 4)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted0
}

///|
pub fn filesystem_error_code(err : @error.Error_) -> ErrorCode? {
  let @error.Error_(handle) = err
  let return_area = mbt_ffi_malloc(2)
  wasmImportFilesystemErrorCode(handle, return_area)
  let lifted : ErrorCode? = match mbt_ffi_load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(ErrorCode::from(mbt_ffi_load8_u(return_area + 1)))
    _ => panic()
  }
  mbt_ffi_free(return_area)
  return lifted
}
